/* Auto-generated by cbindgen. Do not edit by hand. */


#ifndef KAYTON_API_H
#define KAYTON_API_H

#pragma once

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Status codes: 0 = Ok, 1 = Error
 */
typedef enum KaytonStatus {
  Ok = 0,
  Error = 1,
} KaytonStatus;

/**
 * Opaque global handle (u64 inside)
 */
typedef uint64_t HKayGlobal;

/**
 * Set/overwrite a named u64 global, return handle via out param.
 */
typedef enum KaytonStatus (*SetGlobalU64Fn)(struct KaytonContext *ctx,
                                            const uint8_t *name_ptr,
                                            size_t name_len,
                                            uint64_t value,
                                            HKayGlobal *out_handle);

/**
 * Read an existing u64 global by handle.
 */
typedef enum KaytonStatus (*GetGlobalU64Fn)(struct KaytonContext *ctx,
                                            HKayGlobal handle,
                                            uint64_t *out_value);

/**
 * Set/overwrite a named u8 global, return handle via out param.
 */
typedef enum KaytonStatus (*SetGlobalU8Fn)(struct KaytonContext *ctx,
                                           const uint8_t *name_ptr,
                                           size_t name_len,
                                           uint8_t value,
                                           HKayGlobal *out_handle);

/**
 * Read an existing u8 global by handle.
 */
typedef enum KaytonStatus (*GetGlobalU8Fn)(struct KaytonContext *ctx,
                                           HKayGlobal handle,
                                           uint8_t *out_value);

/**
 * Set/overwrite a named f64 global, return handle via out param.
 */
typedef enum KaytonStatus (*SetGlobalF64Fn)(struct KaytonContext *ctx,
                                            const uint8_t *name_ptr,
                                            size_t name_len,
                                            double value,
                                            HKayGlobal *out_handle);

/**
 * Read an existing f64 global by handle.
 */
typedef enum KaytonStatus (*GetGlobalF64Fn)(struct KaytonContext *ctx,
                                            HKayGlobal handle,
                                            double *out_value);

/**
 * Set/overwrite a named f32 global, return handle via out param.
 */
typedef enum KaytonStatus (*SetGlobalF32Fn)(struct KaytonContext *ctx,
                                            const uint8_t *name_ptr,
                                            size_t name_len,
                                            float value,
                                            HKayGlobal *out_handle);

/**
 * Read an existing f32 global by handle.
 */
typedef enum KaytonStatus (*GetGlobalF32Fn)(struct KaytonContext *ctx,
                                            HKayGlobal handle,
                                            float *out_value);

/**
 * Single flat vtable (HPy-style). Append new fields at the end only!
 */
typedef struct KaytonApi {
  /**
   * sizeof(KaytonApi). Plugins can feature-detect by comparing this value.
   */
  uint64_t size;
  SetGlobalU64Fn set_global_u64;
  GetGlobalU64Fn get_global_u64;
  SetGlobalU8Fn set_global_u8;
  GetGlobalU8Fn get_global_u8;
  SetGlobalF64Fn set_global_f64;
  GetGlobalF64Fn get_global_f64;
  SetGlobalF32Fn set_global_f32;
  GetGlobalF32Fn get_global_f32;
  const void *_reserved0;
  const void *_reserved1;
  const void *_reserved2;
  const void *_reserved3;
} KaytonApi;

/**
 * Opaque VM context surface passed to plugins
 */
typedef struct KaytonContext {
  /**
   * ABI version (bump on breaking changes)
   */
  uint64_t abi_version;
  /**
   * Host-owned, plugin-opaque pointer (your VM can stash anything here).
   */
  void *host_data;
  /**
   * Root API vtable (flat, HPy-style)
   */
  const struct KaytonApi *api;
} KaytonContext;

#endif /* KAYTON_API_H */
